<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#0078E7"><meta name="author" content="彩鹏"><meta name="copyright" content="彩鹏"><meta name="generator" content="Hexo 5.4.0"><meta name="theme" content="hexo-theme-yun"><title>Javascript - 面向对象 | 彩鹏的小站</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/star-markdown-css@0.1.25/dist/yun/yun-markdown.min.css"><script src="//at.alicdn.com/t/font_1140697_j5gk85dg4pf.js" async></script><script src="https://cdn.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>document.addEventListener("DOMContentLoaded", () => {
  [".post-card",".post-content img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
});
</script><link rel="icon" href="/yun.svg"><link rel="mask-icon" href="/yun.svg" color="#0078E7"><link rel="alternate icon" href="/yun.ico"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="preload" href="/js/utils.js" as="script"><link rel="preload" href="/js/hexo-theme-yun.js" as="script"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><script id="yun-config">
    const Yun = window.Yun || {};
    window.CONFIG = {"hostname":"blog.gaocaipeng.com","root":"/","title":"彩鹏的小站","version":"1.6.1","mode":"auto","copycode":true,"page":{"isPost":true},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}.","hits":"${hits} results found","hits_time":"${hits} results found in ${time} ms"},"anonymous_image":"https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/avatar/none.jpg","say":{"api":"https://v1.hitokoto.cn","hitokoto":true},"local_search":{"path":"/search.xml"},"fireworks":{"colors":["102, 167, 221","62, 131, 225","33, 78, 194"]}};
  </script><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script src="/js/utils.js"></script><script src="/js/hexo-theme-yun.js"></script><meta name="description" content="初步了解面向过程面向过程是一种以过程为中心的编程思想。面向过程也可以称之为‘面向记录’的编程思想，他们不支持丰富的面向对象特征（比如继承，多态），并且他们不允许混合持久化状态和域逻辑。就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。面向过程其实是最为实际的一种思考方式，就算是面向对象的方法也是含有面向过程的思想。可以说面向过程是一种基础的方法。">
<meta property="og:type" content="article">
<meta property="og:title" content="Javascript - 面向对象">
<meta property="og:url" content="https://blog.gaocaipeng.com/2020/03/12/mi580a/index.html">
<meta property="og:site_name" content="彩鹏的小站">
<meta property="og:description" content="初步了解面向过程面向过程是一种以过程为中心的编程思想。面向过程也可以称之为‘面向记录’的编程思想，他们不支持丰富的面向对象特征（比如继承，多态），并且他们不允许混合持久化状态和域逻辑。就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。面向过程其实是最为实际的一种思考方式，就算是面向对象的方法也是含有面向过程的思想。可以说面向过程是一种基础的方法。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://oss-peng.oss-cn-beijing.aliyuncs.com/blog/1601293244051-184b0a0e-8499-46cf-9347-778acee763c5.jpeg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_6auY5b2p6bmP,color_ef9191,size_30,shadow_100,x_15,y_15#id=HTU3j&originHeight=439&originWidth=652&originalType=binary%E2%88%B6=1&status=done&style=none">
<meta property="og:image" content="https://oss-peng.oss-cn-beijing.aliyuncs.com/blog/1601293244051-184b0a0e-8499-46cf-9347-778acee763c5.jpeg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_6auY5b2p6bmP,color_ef9191,size_30,shadow_100,x_15,y_15#id=NNQT9&originHeight=439&originWidth=652&originalType=binary%E2%88%B6=1&status=done&style=none">
<meta property="article:published_time" content="2020-03-12T05:19:54.000Z">
<meta property="article:modified_time" content="2022-01-05T02:19:20.680Z">
<meta property="article:author" content="彩鹏">
<meta property="article:tag" content="面向对象">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://oss-peng.oss-cn-beijing.aliyuncs.com/blog/1601293244051-184b0a0e-8499-46cf-9347-778acee763c5.jpeg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_6auY5b2p6bmP,color_ef9191,size_30,shadow_100,x_15,y_15#id=HTU3j&originHeight=439&originWidth=652&originalType=binary%E2%88%B6=1&status=done&style=none"><script src="/js/ui/mode.js"></script></head><body><script defer src="https://cdn.jsdelivr.net/npm/animejs@latest"></script><script defer src="/js/ui/fireworks.js"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="Table of Contents"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-list-ordered"></use></svg></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="Overview"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-passport-line"></use></svg></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="彩鹏"><img width="96" loading="lazy" src="/images/atm.webp" alt="彩鹏"><span class="site-author-status" title="永远相信美好的事情即将发生">😊</span></a><div class="site-author-name"><a href="/about/">彩鹏</a></div><a class="site-name" href="/about/site.html">彩鹏的小站</a><sub class="site-subtitle">All at sea.</sub><div class="site-desciption">希望能成为一个有趣的人</div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="首页"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-home-4-line"></use></svg></span></a><div class="site-state-item"><a href="/archives/" title="Archives"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-archive-line"></use></svg></span><span class="site-state-item-count">182</span></a></div><div class="site-state-item"><a href="/categories/" title="Categories"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-2-line"></use></svg></span><span class="site-state-item-count">28</span></a></div><div class="site-state-item"><a href="/tags/" title="Tags"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="site-state-item-count">188</span></a></div><a class="site-state-item hty-icon-button" href="/" title="文档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-settings-line"></use></svg></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/gaocaipeng" title="GitHub" target="_blank" style="color:#6e5494"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-github-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://music.163.com/#/user/home?id=1309947697" title="网易云音乐" target="_blank" style="color:#C20C0C"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-netease-cloud-music-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://www.zhihu.com/people/du-xiao-sheng-dian-a" title="知乎" target="_blank" style="color:#0084FF"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-zhihu-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="mailto:peng25402@163.com" title="E-Mail" target="_blank" style="color:#8E71C1"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-mail-line"></use></svg></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-contrast-2-line"></use></svg></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">概念</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B5%85%E8%B0%88%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number"></span> <span class="toc-text">浅谈面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5%EF%BC%9A"><span class="toc-number">0.1.</span> <span class="toc-text">概念：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%80%A7%EF%BC%9A"><span class="toc-number">0.2.</span> <span class="toc-text">特性：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E6%80%A7%EF%BC%9A"><span class="toc-number">0.3.</span> <span class="toc-text">抽象性：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E6%80%A7%EF%BC%9A"><span class="toc-number">0.4.</span> <span class="toc-text">继承性：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%80%E4%BA%9B%E5%85%B6%E4%BB%96%E6%A6%82%E5%BF%B5%EF%BC%9A"><span class="toc-number">0.5.</span> <span class="toc-text">关于面向对象的一些其他概念：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB-class%EF%BC%9A%E5%9C%A8-JS-%E4%B8%AD%E5%B0%B1%E6%98%AF%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="toc-number">0.6.</span> <span class="toc-text">类 class：在 JS 中就是构造函数：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%EF%BC%88instance%EF%BC%89%E4%B8%8E%E5%AF%B9%E8%B1%A1%EF%BC%88object%EF%BC%89%EF%BC%9A"><span class="toc-number">0.7.</span> <span class="toc-text">实例（instance）与对象（object）：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%AE%E5%80%BC%E5%AF%B9%E4%B8%8E%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">0.8.</span> <span class="toc-text">键值对与属性和方法：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%88%B6%E7%B1%BB%E4%B8%8E%E5%AD%90%E7%B1%BB%EF%BC%88%E5%9F%BA%E7%B1%BB%E5%92%8C%E6%B4%BE%E7%94%9F%E7%B1%BB%EF%BC%89%EF%BC%9A"><span class="toc-number">0.9.</span> <span class="toc-text">父类与子类（基类和派生类）：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number"></span> <span class="toc-text">构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%98%AF%E5%B9%B2%E4%BB%80%E4%B9%88%E7%94%A8%E7%9A%84%EF%BC%9A"><span class="toc-number">0.1.</span> <span class="toc-text">构造函数是干什么用的：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">0.2.</span> <span class="toc-text">创建对象的过程:</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number"></span> <span class="toc-text">作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%9A"><span class="toc-number">0.1.</span> <span class="toc-text">什么是作用域：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#js-%E4%B8%AD%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E8%A7%84%E5%88%99"><span class="toc-number">0.2.</span> <span class="toc-text">js 中词法作用域的规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E6%90%9C%E7%B4%A2%E5%8E%9F%E5%88%99"><span class="toc-number">0.3.</span> <span class="toc-text">属性搜索原则</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%97%AD%E5%8C%85"><span class="toc-number"></span> <span class="toc-text">闭包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E9%97%AD%E5%8C%85%E7%9A%84%E6%B5%85%E5%BA%A6%E7%90%86%E8%A7%A3"><span class="toc-number">0.1.</span> <span class="toc-text">对闭包的浅度理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AD%E5%8C%85%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%88%E7%89%B9%E6%80%A7%EF%BC%89"><span class="toc-number">0.2.</span> <span class="toc-text">闭包有什么用（特性）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AD%E5%8C%85%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9E%8B"><span class="toc-number">0.3.</span> <span class="toc-text">闭包的基本模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AD%E5%8C%85%E7%9A%84%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98"><span class="toc-number">0.4.</span> <span class="toc-text">闭包的性能问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B"><span class="toc-number"></span> <span class="toc-text">原型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8E%9F%E5%9E%8B"><span class="toc-number">0.1.</span> <span class="toc-text">什么是原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8E%9F%E5%9E%8B"><span class="toc-number">0.2.</span> <span class="toc-text">查看对象的原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-number">0.3.</span> <span class="toc-text">原型的用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="toc-number">0.4.</span> <span class="toc-text">原型链</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number"></span> <span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B7%E5%90%88%E5%BC%8F%E7%BB%A7%E6%89%BF"><span class="toc-number">0.1.</span> <span class="toc-text">混合式继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF"><span class="toc-number">0.2.</span> <span class="toc-text">原型继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%80%9F%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%BB%A7%E6%89%BF"><span class="toc-number">0.3.</span> <span class="toc-text">借用构造函数继承</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E5%9B%9B%E7%A7%8D%E8%B0%83%E7%94%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number"></span> <span class="toc-text">函数的四种调用模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E5%BC%8F"><span class="toc-number">0.1.</span> <span class="toc-text">函数模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F"><span class="toc-number">0.2.</span> <span class="toc-text">方法模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8%E8%B0%83%E7%94%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">0.3.</span> <span class="toc-text">构造器调用模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E8%B0%83%E7%94%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">0.4.</span> <span class="toc-text">上下文调用模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.</span> <span class="toc-text">设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.1.</span> <span class="toc-text">工厂模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.2.</span> <span class="toc-text">构造模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.3.</span> <span class="toc-text">原型模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.4.</span> <span class="toc-text">单例模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85"><span class="toc-number">1.5.</span> <span class="toc-text">发布订阅</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.6.</span> <span class="toc-text">观察者模式</span></a></li></ol></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="hty-card post-block" itemscope itemtype="https://schema.org/Article"><link itemprop="mainEntityOfPage" href="https://blog.gaocaipeng.com/2020/03/12/mi580a/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="彩鹏"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="彩鹏的小站"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Javascript - 面向对象</h1><div class="post-meta"><div class="post-time" style="display:inline-block"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-line"></use></svg></span> <time title="Created: 2020-03-12 05:19:54" itemprop="dateCreated datePublished" datetime="2020-03-12T05:19:54+00:00">2020-03-12</time><span class="post-meta-divider">-</span><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-2-line"></use></svg></span> <time title="Modified: 2022-01-05 02:19:20" itemprop="dateModified" datetime="2022-01-05T02:19:20+00:00">2022-01-05</time></div><div class="post-classify"><span class="post-category"> <span class="post-meta-item-icon" style="margin-right:3px;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-line"></use></svg></span><span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category-item" href="/categories/Javascript/" style="--text-color:var(--hty-text-color)" itemprop="url" rel="index"><span itemprop="text">Javascript</span></a></span></span><span class="post-tag"><span class="post-meta-divider">-</span><a class="tag-item" href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">面向对象</span></a></span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body" style="--smc-primary:#0078E7;"><p><img src="https://oss-peng.oss-cn-beijing.aliyuncs.com/blog/1601293244051-184b0a0e-8499-46cf-9347-778acee763c5.jpeg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_6auY5b2p6bmP,color_ef9191,size_30,shadow_100,x_15,y_15#id=HTU3j&originHeight=439&originWidth=652&originalType=binary%E2%88%B6=1&status=done&style=none" loading="lazy"><br>初步了解面向过程<br>面向过程是一种以过程为中心的编程思想。<br>面向过程也可以称之为‘面向记录’的编程思想，他们不支持丰富的面向对象特征（比如继承，多态），并且他们不允许混合持久化状态和域逻辑。就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。<br>面向过程其实是最为实际的一种思考方式，就算是面向对象的方法也是含有面向过程的思想。可以说面向过程是一种基础的方法。它考虑的是实际的实现。一般的面向过程是从上往下步步求精，所以面向过程最重要的是模块化的思想方法。对比面向过程，面向对象的方法主要是把事务给对象化，对象包括属性与行为。当程序规模不是很大时，面向过程的方法还会体验出一种优势。因为程序的流程很清楚，按着模块与函数的方法可以很好的组织。比如拿郝志枪喝茶这件事来说明面向过程，将过程拟为：<br>1：把昨天的茶叶倒掉<br>2：把杯子涮干净<br>3：倒进去茶叶<br>4：倒入开水<br>5：盖上杯盖等着喝<br>这几个步骤是一步一步去完成的，它的顺序很重要，只需要一个一个去实现就行了。而如果用面向对象放的的话，可能就只能抽象出一个郝志枪的类，它包括这四个方法，但是具体的顺序就不一定按照原来的顺序。<br><strong>总结来说，面向过程就是分析出实现需求所需要的步骤，然后通过函数一步一步实现这个步骤，然后依次调用即可</strong></p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li>父类、子类</li>
<li>基类、派生类</li>
</ul>
<h1 id="浅谈面向对象"><a href="#浅谈面向对象" class="headerlink" title="浅谈面向对象"></a>浅谈面向对象</h1><h3 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h3><p>面向过程的编程方式由来已久。这种方式非常的直观，需要写一个功能，直接就写几行实现方法。比如你需要操作一个人移动到某个点，直接就写代码修改一个人的坐标属性，逐格的让他移动到目标点就行了<br>面向对象的编程方式，操作的是一个个的对象，比如你还是需要操作一个人的移动，你需要先实例化那个人的一个管理类对象，然后告诉这个“人”的对象，你需要移动到什么地方去。然后人就自己走过去了。至于具体是怎样走的，外部不关心，只有“人”对象本身知道</p>
<h3 id="特性："><a href="#特性：" class="headerlink" title="特性："></a>特性：</h3><h3 id="抽象性："><a href="#抽象性：" class="headerlink" title="抽象性："></a>抽象性：</h3><p>所谓的抽象性就是：如果需要一个对象描述数据，需要抽取这个对象的核心数据<br>提出需要的核心属性和方法<br>不在特定的环境下无法明确对象的具体意义</p>
<h3 id="继承性："><a href="#继承性：" class="headerlink" title="继承性："></a><strong>继承性：</strong></h3><p>所谓继承性就是自己没有但是别人有，拿过来成为自己的，就是继承，继承是实现复用的一种手段<br>在 Java 等语言中继承满足一个 class 的规则，类是一个 class，他规定了一个对象有什么属性和方法。<br>在这些语言中继承是 class 之间的继承，一个 class 继承另一个 class，那么该 class 就有了另一个 class 的成员，那么由该 class 创建出来的对象就同时具有两个 class 的成员。<br>在 JS 中没有明确的继承语法（ES6 提供了 class extend 语法），一般都是按照继承的理念实现对象的成员扩充实现继承，因此 JS 中实现继承的方法非常对多。<br>传统继承基于类，JS 继承基于对象</p>
<h3 id="关于面向对象的一些其他概念："><a href="#关于面向对象的一些其他概念：" class="headerlink" title="关于面向对象的一些其他概念："></a>关于面向对象的一些其他概念：</h3><h3 id="类-class：在-JS-中就是构造函数："><a href="#类-class：在-JS-中就是构造函数：" class="headerlink" title="类 class：在 JS 中就是构造函数："></a><strong>类 class：在 JS 中就是构造函数：</strong></h3><p>在传统的面向对象语言中，使用一个叫类的东西定义模板，然后使用模板创建对象。<br>在构造方法中也具有类似的功能，因此也称其为类</p>
<h3 id="实例（instance）与对象（object）："><a href="#实例（instance）与对象（object）：" class="headerlink" title="实例（instance）与对象（object）："></a><strong>实例（instance）与对象（object）：</strong></h3><p>实例一般是指某一个构造函数创建出来的对象，我们称为 XXXX 构造函数的实例<br>实例就是对象。对象是一个泛称<br>实例与对象是一个近义词</p>
<h3 id="键值对与属性和方法："><a href="#键值对与属性和方法：" class="headerlink" title="键值对与属性和方法："></a><strong>键值对与属性和方法：</strong></h3><p>在 JS 中键值对的集合称为对象<br>如果值为数据（非函数），就称该键值对为属性<br>如果值为函数（方法），就称该键值对为方法 method</p>
<h3 id="父类与子类（基类和派生类）："><a href="#父类与子类（基类和派生类）：" class="headerlink" title="父类与子类（基类和派生类）："></a><strong>父类与子类（基类和派生类）：</strong></h3><p>传统的面向对象语言中使用类来实现继承那么就有父类、子类的概念<br>父类又称为基类，子类又称为派生类<br>在 JS 中没有类的概念，在 JS 中常常称为父对象，子对象，基对象，派生对象。</p>
<h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><h3 id="构造函数是干什么用的："><a href="#构造函数是干什么用的：" class="headerlink" title="构造函数是干什么用的："></a>构造函数是干什么用的：</h3><p>初始化数据的<br>在 js 中给对象添加属性用的，初始化属性用</p>
<h3 id="创建对象的过程"><a href="#创建对象的过程" class="headerlink" title="创建对象的过程:"></a>创建对象的过程:</h3><p>代码：var p = new Person();<br>首先运算符 new 创建了一个对象，类似于{}，是一个没有任何（自定义）成员的对象。<br>使用 new 创建对象，那么对象的类型就是创建他的构造函数名<br>使用{}无论如何都是 Object 类型，相当于 new Object<br>然后调用构造函数，为其初始化成员<br>构造函数在调用的一开始，有一个赋值操作，即 this = 刚刚创建出来的对象<br>因此在构造函数中 this 表示刚刚创建出来的对象。<br>在构造函数中 利用 对象的动态特性 为其对象添加成员</p>
<h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><h3 id="什么是作用域："><a href="#什么是作用域：" class="headerlink" title="什么是作用域："></a>什么是作用域：</h3><p>域表示的就是范围，即作用域，就是一个名字在什么地方可以使用，什么时候不能使用。<br>简单的说，作用域是针对变量的，比如我们创建一个函数 a1，函数里面又包了一个子函数 a2。</p>
<p>| 1<br>2<br>3<br>4<br>5<br>6<br>7 | // 全局作用域<br>functiona a1() {<br>​// a1 作用域<br>​functiona2() {<br>​// a2 作用域<br>​}<br>} |<br>| — | — |</p>
<p>此时就存 在三个作用域:全局作用域，a1 作用域，a2 作用域；即全局作用域包含了 a1 的作用域，a2 的作用域包含了 a1 的作用域。<br>当 a2 在查找变量的时候会先从自身的作用域区查找，找不到再到上一级 a1 的作用域查找，如果还没找到就<br>到全局作用域区查找，这样就形成了一个作用域链。</p>
<h3 id="js-中词法作用域的规则"><a href="#js-中词法作用域的规则" class="headerlink" title="js 中词法作用域的规则"></a>js 中词法作用域的规则</h3><p>函数允许访问函数外部的数据<br>整个代码结构只有函数可以限定作用域<br>作用规则首先使用提升规则分析<br>如果当前作用域中有了名字了，就不考虑外面的名字</p>
<h3 id="属性搜索原则"><a href="#属性搜索原则" class="headerlink" title="属性搜索原则"></a>属性搜索原则</h3><p>所谓的属性搜索原则，就是对象在访问属性或方法的时候，首先在当前对象中查找<br>如果当前对象中存储着属性或方法，停止查找，直接使用该属性或方法<br>如果当前对象没有该成员，那么再在其原型对象中查找<br>如果原型对象中含有该成员，那么停止查找，直接使用<br>如果圆形中还没有，就到原型的原型中查找<br>如此往复，知道 Object.protitype 还没有，那么返回 undefined<br>如果是调用方法就报错，该 xxx 不是一个函数</p>
<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><h3 id="对闭包的浅度理解"><a href="#对闭包的浅度理解" class="headerlink" title="对闭包的浅度理解"></a>对闭包的浅度理解</h3><p>实用闭包主要是为了设计私有方法和变量。闭包的优点是可以避免全局变量的污染；缺点是闭包会常驻内存，增加内存使用量，使用不当很容易造成内存泄露。在 JavaScript 中，函数即闭包，只有函数才能产生作用域。<br>闭包的三个特性：<br>函数嵌套函数<br>在函数内部可以引用外部的参数和变量<br>参数和变量不会以垃圾回收机制回收</p>
<h3 id="闭包有什么用（特性）"><a href="#闭包有什么用（特性）" class="headerlink" title="闭包有什么用（特性）"></a>闭包有什么用（特性）</h3><p>闭包的作用，就是保存自己私有的变量，通过提供的接口(方法)给外部使用，但外部不能直接访问该变量。<br>通过使用闭包，我们可以做很多事情，比如模拟面向对象的代码风格；更优雅，更简洁的表达出代码；在某些方面提升代码的执行效率。利用闭包可以实现如下需求：<br>匿名自执行函数：：<br>一个匿名的函数，并立即执行它，由于外部无法引用它内部的变量，因此在执行完后很快就会被释放，关键是这种机制不会污染全局对象<br>缓存：：<br>闭包正事可以做到这一点，因为它不会释放外部的引用，从而函数内部的值可以得到保留<br>实现封装：：<br>模拟面向对象的代码风格：：</p>
<h3 id="闭包的基本模型"><a href="#闭包的基本模型" class="headerlink" title="闭包的基本模型"></a>闭包的基本模型</h3><p><strong>对象模式</strong><br>函数内部定义个一个对象，对象中绑定多个函数（方法），返回对象，利用对象的方法访问函数内的数据</p>
<p>| 1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21 | functioncreatePerson() {<br>​var<strong>name</strong> = “”;<br>​return{<br>​getName: function() {<br>​return<strong>name</strong>;<br>​},<br>​setName: function( value ) {<br>​// 如果不姓张就报错<br>​if( value.charAt(0) === ‘张’) {<br>​<strong>name</strong> = value;<br>​} else{<br>​thrownewError( ‘姓氏不对，不能取名’);<br>​}<br>​}<br>​}<br>}<br>varp = createPerson();<br>p.set_Name( ‘张三丰’);<br>console.log( p.get_Name() );<br>p.set_Name( ‘张王富贵’);<br>console.log( p.get_Name() ); |<br>| — | — |</p>
<p><strong>函数模式</strong><br>函数内部定义一个新函数，返回新函数，用新函数获得函数内的数据</p>
<p>| 1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11 | functionfoo() {<br>​varnum = Math.random();<br>​functionfunc() {<br>​returnmun;<br>​}<br>​returnfunc;<br>}<br>varf = foo();<br>// f 可以直接访问这个 num<br>varres1 = f();<br>varres2 = f(); |<br>| — | — |</p>
<p><strong>沙箱模式</strong><br>沙箱模式就是一个自调用函数，代码写到函数中一样会执行，但是不会与外界有任何的影响，比如 jQuery</p>
<p>| 1<br>2<br>3<br>4<br>5<br>6 | (function() {<br>​varjQuery = function() { // 所有的算法 }<br>​// …. // …. jQuery.each = function () {}<br>​window.jQuery = window.$ = jQuery;<br>})();<br>$.each( … ) |<br>| — | — |</p>
<h3 id="闭包的性能问题"><a href="#闭包的性能问题" class="headerlink" title="闭包的性能问题"></a>闭包的性能问题</h3><p>js 垃圾回收机制，也就是当一个函数被执行完后，其作用域会被收回，如果形成了闭包，执行完后其作用域不会被收回<br>函数执行需要内存，那么函数中定义的变量，会在函数执行结束后自动回收，凡是因为闭包结构的，被引出的数据，如果还有变量引用这些数据的话，那么这些数据就不会被回收。因此在使用闭包的时候如果不使用某些数据了，一定要赋值一个 null</p>
<p>| 1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9 | varf = (function() {<br>​varnum = 123;<br>​returnfunction() {<br>​returnnum;<br>​};<br>})();<br>// f 引用着函数，函数引用着变量 num<br>// 因此在不使用该数据的时候，最好写上<br>f = null; |<br>| — | — |</p>
<h1 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h1><h3 id="什么是原型"><a href="#什么是原型" class="headerlink" title="什么是原型"></a>什么是原型</h3><p>一句话说明什么是原型：原型能存储我们的方法，构造函数创建出来的实例对象能够引用原型中的方法。<br>JS 中一切皆对象，而每个对象都有一个原型（Object 除外），这个原型，大概就像 Java 中的父类，所以，基本上你可以认为原型就是这个对象的父对象，即每一个对象（Object 除外）内部都保存了它自己的父对象，这个父对象就是原型。一般创建的对象如果没有特别指定原型，那么它的原型就是 Object(这就很类似 Java 中所有的类默认继承自 Object 类)。<br>ES6 通过引入 class ,extends 等关键字，以一种语法糖的形式把构造函数包装成类的概念，更便于大家理解。是希望开发者不再花精力去关注原型以及原型链，也充分说明原型的设计意图和类是一样的。</p>
<h3 id="查看对象的原型"><a href="#查看对象的原型" class="headerlink" title="查看对象的原型"></a>查看对象的原型</h3><p>当对象被创建之后，查看它们的原型的方法不止一种，以前一般使用对象的<strong>proto</strong>属性，ES6 推出后，推荐用 Object.getPrototypeOf()方法来获取对象的原型</p>
<p>| 1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10 | functionA(){<br>​this.name=’lala’;<br>}<br>vara=newA();<br>console.log(a.<strong>proto</strong>)<br>//输出：Object {}<br>​</p>
<p>//推荐使用这种方式获取对象的原型<br>console.log(Object.getPrototypeOf(a))<br>//输出：Object {} |<br>| — | — |</p>
<p>无论对象是如何创建的，默认原型都是 Object，在这里需要提及的比较特殊的一点就是，通过构造函数来创建对象，函数 A 本身也是一个对象，而 A 有两个指向表示原型的属性，分别是<strong>proto</strong>和 prototype，而且两个属性并不相同</p>
<p>| 1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11 | functionA(){<br>​this.name=’lala’;<br>}<br>vara=newA();<br>console.log(A.prototype)<br>//输出：Object {}<br>​</p>
<p>console.log(A.<strong>proto</strong>)<br>//输出：function () {}<br>console.log(Object.getPrototypeOf(A))<br>//输出：function () {} |<br>| — | — |</p>
<p>函数的的 prototype 属性只有在当作构造函数创建的时候，把自身的 prototype 属性值赋给对象的原型。而实际上，作为函数本身，它的原型应该是 function 对象，然后 function 对象的原型才是 Object。<br><strong>总之，建议使用 ES6 推荐的查看原型和设置原型的方法。</strong></p>
<h3 id="原型的用法"><a href="#原型的用法" class="headerlink" title="原型的用法"></a>原型的用法</h3><p>其实原型和类的继承的用法是一致的：当你想用某个对象的属性时，将当前对象的原型指向该对象，你就拥有了该对象的使用权了。</p>
<p>| 1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13 | functionA(){<br>​this.name=’world ‘;<br>}<br>functionB(){<br>​this.bb=”hello”<br>}<br>vara=newA();<br>varb=newB();<br>​</p>
<p>//将 b 设置为 a 的原型,此处有一个问题，即 a 的 constructor 也指向了 B 构造函数，可能需要纠正<br>Object.setPrototypeOf(a,b);<br>a.constructor=A;<br>console.log(a.bb); //hello |<br>| — | — |</p>
<p>如果使用 ES6 来做的话则简单许多，甚至不涉及到 prototype 这个属性</p>
<p>| 1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15 | class B{<br>​constructor(){<br>​this.bb=’hello’<br>​}<br>}<br>class A extends B{<br>​constructor(){<br>​super();<br>​this.name=’world’;<br>​}<br>}<br>​</p>
<p>vara=newA();<br>console.log(a.bb+” “+a.name); //hello world<br>console.log(typeof(A)) //“function” |<br>| — | — |</p>
<p>怎么样？是不是已经完全看不到原型的影子了？活脱脱就是类继承，但是你也看得到实际上类 A 的类型是 function，所以说，本质上 class 在 JS 中是一种语法糖，JS 继承的本质依然是原型，不过，ES6 引入 class，extends 来掩盖原型的概念也是一个很友好的举动，对于长期学习那些类继承为基础的面对对象编程语言的程序员而言。<br>我的建议是，尽可能理解原型，尽可能用 class 这种语法糖。<br>好了，问自己两个问题：</p>
<ol>
<li>为什么要使用原型？——提高函数的复用性。</li>
<li>为什么属性不放在原型上而方法要放在原型上？</li>
</ol>
<p>利用对象的动态特性：构造函数.prototype.xxxx = vvv<br>利用直接替换</p>
<p>| 1<br>2<br>3<br>4 | Student.prototype = {<br>sayHello : function(){},<br>study : function(){}<br>}; |<br>| — | — |</p>
<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>什么是原型链<br>凡是对象就有原型，那么原型又是对象，因此凡是给定一个对象，那么就可以找到他的原型，原型还有原型，那么如此下去，就构成一个对象的序列，称该结构为原型链。<br>每个实例对象都有一个<strong>proto_<br>属性，该属性指向它原型对象，这个实例对象 的构造函数有一个原型属性 prototype<br>，与实例的</strong>proto**<br>属性指向同一个对象。当一个对象在查找一个属性的时， 自身没有就会根据**proto__<br>向它的原型进行查找，如果都没有，则向它的原型的原型继续查找，直到查到 Object.prototype._proto_<br>为 null<br>，这样也就形成了原型链<br>。<br>这个概念其实也变得比较简单，可以类比类的继承链条，即每个对象的原型往上追溯，一直到 Object 为止，这组成了一个链条，将其中的对象串联起来，当查找当前对象的属性时，如果没找到，就会沿着这个链条去查找，一直到 Object，如果还没发现，就会报 undefined。<br><strong>原型链的结构</strong><br>凡是使用构造函数，创建出对象，并且没有利用赋值的方式修改原型，就说该对象保留默认的原型链。<br>默认原型链结构是什么样子呢？</p>
<p>| 1<br>2<br>3 | functionPerson(){}<br>varp = newPerson();<br>//p 具有默认的原型链 |<br>| — | — |</p>
<p>默认的原型链结构就是：当前对象 -&gt; 构造函数.prototype -&gt; Object.prototype -&gt; null<br>在实现继承的时候，有时候会利用替换原型链结构的方式实现原型继承，那么原型链结构就会发生改变</p>
<p>| 1<br>2<br>3 | functionDunizbCollection(){}<br>DunizbCollection.prototype = [];<br>vararr = newDunizbCollection(); |<br>| — | — |</p>
<p>此时 arr 对象的原型链结构被指向了数组对象的原型链结构了：arr -&gt; [] -&gt; Array.prototype -&gt; Object.prototype -&gt; null<br><strong>用图形表示对象的原型链结构</strong><br>以如下代码为例绘制原型链结构</p>
<p>| 1<br>2 | functionPerson(){}<br>varp = newPerson(); |<br>| — | — |</p>
<p>原型链结构图为：</p>
<p><img src="https://oss-peng.oss-cn-beijing.aliyuncs.com/blog/1601293244051-184b0a0e-8499-46cf-9347-778acee763c5.jpeg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_6auY5b2p6bmP,color_ef9191,size_30,shadow_100,x_15,y_15#id=NNQT9&originHeight=439&originWidth=652&originalType=binary%E2%88%B6=1&status=done&style=none" loading="lazy"><br>使用原型需要注意两点：</p>
<ol>
<li> 原型继承链条不要太长，否则会出现效率问题。</li>
<li> 指定原型时，注意 constructor 也会改变。</li>
</ol>
<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>实现继承有两种常见方式</p>
<h3 id="混合式继承"><a href="#混合式继承" class="headerlink" title="混合式继承"></a>混合式继承</h3><p>最简单的继承就是将别的对象的属性强加到我身上，那么我就有这个成员了<br>混合式继承的简单描述：</p>
<p>| 1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11 | functionPerson() {};<br>Person.prototype.extend = function( o ) {<br>​for( vark ino ) {<br>​this[ k ] = o[ k ];<br>​}<br>};<br>Person.prototype.extend({<br>​run: function() { console.log( ‘我能跑了’); },<br>​eat: function() { console.log( ‘我可以吃了’); },<br>​sayHello: function() { console.log( ‘我吃饱了’); }<br>}); |<br>| — | — |</p>
<h3 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h3><p>利用原型也可以实现继承，不需要在我身上添加任何成员，只要原型有了我就有了</p>
<h3 id="借用构造函数继承"><a href="#借用构造函数继承" class="headerlink" title="借用构造函数继承"></a>借用构造函数继承</h3><p>这种技术的基本思想相当简单，即在子类型构造函数的内部调用超类型的构造函数，而函数只不过是在特定环境中执行代码的对象，因此通过使用 apply（）和 call（）方法也可以在（将来）新创建的对象上执行构造函数</p>
<p>| 1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11 | functionPerson ( name, age, gender ) {<br>​this.name = name;<br>​this.age = age;<br>​this.gender = gender;<br>}<br>// 需要提供一个 Student 的构造函数创建学生对象<br>// 学生也应该有 name, age, gender, 同时还需要有 course 课程<br>functionStudent ( name, age, gender, course ) {<br>​Person.call( this, name, age, gender )；<br>​this.course = course;<br>} |<br>| — | — |</p>
<h1 id="函数的四种调用模式"><a href="#函数的四种调用模式" class="headerlink" title="函数的四种调用模式"></a>函数的四种调用模式</h1><h3 id="函数模式"><a href="#函数模式" class="headerlink" title="函数模式"></a>函数模式</h3><p>就是一个简单的函数调用。函数名的前面没有任何引导内容。</p>
<p>| 1<br>2<br>3<br>4<br>5<br>6 | functionfoo () {}<br>varfunc = function() {};<br>…<br>foo();<br>func();<br>(function() {} )(); |<br>| — | — |</p>
<p>this 的含义：在函数中 this 表示全局对象，在浏览器中式 window</p>
<h3 id="方法模式"><a href="#方法模式" class="headerlink" title="方法模式"></a>方法模式</h3><p>方法一定式依附与一个对象，将函数赋值给对象的一个属性，那么就成为了方法。</p>
<p>| 1<br>2<br>3<br>4<br>5<br>6 | functionf() {<br>​this.method = function() {};<br>}<br>varo = {<br>​method: function() {}<br>} |<br>| — | — |</p>
<p>this 的含义：这个依附的对象</p>
<h3 id="构造器调用模式"><a href="#构造器调用模式" class="headerlink" title="构造器调用模式"></a>构造器调用模式</h3><p>创建对象的时候构造函数做了什么？由于构造函数只是给 this 添加成员，没有做其他事情。而方法也可以完成这个操作，就是 this 而言，构造函数与方法没有本质的区别。</p>
<p>特征：</p>
<p>使用 new 关键字，来引导构造函数。<br>构造函数中的 this 与方法中的一样，表示对象，但是构造函数中的对象是刚刚创建出来的对象<br>构造函数中不需要 return ，就会默认的 return this。</p>
<p>如果手动添加 return ，就相当于 return this<br>如果手动的添加 return 基本类型，无效，还是保留原来 返回 this<br>如果手动添加的 return null，或 return undefined ，无效<br>如果手动添加 return 对象类型，那么原来创建的 this 就会被丢掉，返回的是 return 后面的对象</p>
<h3 id="上下文调用模式"><a href="#上下文调用模式" class="headerlink" title="上下文调用模式"></a>上下文调用模式</h3><p>上下文就是环境。就是自己定义设置 this 的含义。<br><strong>语法</strong><br>函数名.apply( 对象, [ 参数 ] );<br>函数名.call( 对象, 参数 );<br><strong>描述</strong><br>函数名就是表示函数本身，使用函数进行调用的时候默认 this 是全局变量<br>函数名也可以是方法提供，使用方法调用的时候，this 是指向当前对象<br>使用 apply 进行调用后，无论是函数还是方法都无效了，我们的 this ，由 apply 的第一个参数决定<br><strong>参数问题</strong><br>无论是 call 还是 apply 在没有后面的参数的情况下（函数无参数，方法五参数）是完全一致的</p>
<p>| 1<br>2<br>3<br>4<br>5 | functionfoo(){<br>​console.log( this);<br>}<br>foo.apply( obj );<br>foo.call( obj ); |<br>| — | — |</p>
<p>第一个参数的使用也是有规则的:<br>如果传入的是一个对象，那么就相当于设置该函数中的 this 为参数<br>如果不传入参数，或传入 null、undefined 等，那么相当于 this 默认为 window</p>
<p>| 1<br>2<br>3 | foo();<br>foo.apply();<br>foo.apply( null); |<br>| — | — |</p>
<p>如果传入的是基本类型，那么 this 就是基本类型对应的包装类型的引用<br>在使用上下文调用的时候，原函数（方法）可能会带有参数，那么这个参数再上下文调用中使用 第二个（第 n 个）参数来表示</p>
<p>| 1<br>2<br>3<br>4<br>5<br>6 | functionfoo( num ) {<br>​console.log( num );<br>}<br>foo.apply( null, [ 123 ] );<br>// 等价于<br>foo( 123 ); |<br>| — | — |</p>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><h3 id="构造模式"><a href="#构造模式" class="headerlink" title="构造模式"></a>构造模式</h3><h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><h3 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h3><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3></div><div id="reward-container"><span class="hty-icon-button button-glow" id="reward-button" title="Donate" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === &quot;none&quot;) ? &quot;block&quot; : &quot;none&quot;;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-hand-coin-line"></use></svg></span><div id="reward-comment">I'm so cute. Please give me money.</div><div id="qr" style="display:none;"><div style="display:inline-block"><a href="/images/zfb-pay.png"><img loading="lazy" src="/images/zfb-pay.png" alt="支付宝" title="支付宝"></a><div><span style="color:#00A3EE"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-alipay-line"></use></svg></span></div></div><div style="display:inline-block"><a href="/images/qq-pay.png"><img loading="lazy" src="/images/qq-pay.png" alt="QQ 支付" title="QQ 支付"></a><div><span style="color:#12B7F5"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-qq-line"></use></svg></span></div></div><div style="display:inline-block"><a href="/images/wx-pay.png"><img loading="lazy" src="/images/wx-pay.png" alt="微信支付" title="微信支付"></a><div><span style="color:#2DC100"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-wechat-pay-line"></use></svg></span></div></div><div><img loading="lazy" src="/images/wantthis.gif" alt="想要这个" title="伸手要钱"></div></div></div><ul class="post-copyright"><li class="post-copyright-author"><strong>Post author: </strong>彩鹏</li><li class="post-copyright-link"><strong>Post link: </strong><a href="https://blog.gaocaipeng.com/2020/03/12/mi580a/" title="Javascript - 面向对象">https://blog.gaocaipeng.com/2020/03/12/mi580a/</a></li><li class="post-copyright-license"><strong>Copyright Notice: </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><svg class="icon"><use xlink:href="#icon-creative-commons-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-by-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-nc-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-sa-line"></use></svg></a> unless otherwise stated.</li></ul></section></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/2020/03/12/vu6efn/" rel="prev" title="Javascript - 面向过程&amp;面向对象"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-left-s-line"></use></svg><span class="post-nav-text">Javascript - 面向过程&amp;面向对象</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/2020/03/12/vr3dmp/" rel="next" title="ES6 - proxy"><span class="post-nav-text">ES6 - proxy</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-right-s-line"></use></svg></a></div></div></div><div class="hty-card" id="comment"><div class="comment-tooltip text-center"><span>要不要和我说些什么？</span><br></div><div id="tcomment"></div><script src="https://cdn.jsdelivr.net/npm/twikoo@latest/dist/twikoo.all.min.js"></script><script>const twikooConfig = {"enable":true,"envId":"twikoo-1gdwtrnc57e907a9"}
twikooConfig.el = '#tcomment'
twikoo.init(twikooConfig)</script></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2019 – 2022 </span><span class="with-love" id="animate"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-cloud-line"></use></svg></span><span class="author"> 彩鹏</span></div><div class="powered"><span>Powered by <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> v5.4.0</span><span class="footer-separator">|</span><span>Theme - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v1.6.1</span></div><div class="live_time"><span>本博客已萌萌哒地运行</span><span id="display_live_time"></span><span class="moe-text">(●'◡'●)</span><script>function blog_live_time() {
  setTimeout(blog_live_time, 1000);
  const start = new Date('2020-04-26T00:00:00');
  const now = new Date();
  const timeDiff = (now.getTime() - start.getTime());
  const msPerMinute = 60 * 1000;
  const msPerHour = 60 * msPerMinute;
  const msPerDay = 24 * msPerHour;
  const passDay = Math.floor(timeDiff / msPerDay);
  const passHour = Math.floor((timeDiff % msPerDay) / 60 / 60 / 1000);
  const passMinute = Math.floor((timeDiff % msPerHour) / 60 / 1000);
  const passSecond = Math.floor((timeDiff % msPerMinute) / 1000);
  display_live_time.innerHTML = " " + passDay + " 天 " + passHour + " 小时 " + passMinute + " 分 " + passSecond + " 秒";
}
blog_live_time();
</script></div></footer><a class="hty-icon-button" id="back-to-top" aria-label="back-to-top" href="#"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-up-s-line"></use></svg><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"></circle></svg></a><a class="popup-trigger hty-icon-button icon-search" id="search" href="javascript:;" title="Search"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-search-line"></use></svg></span></a><script>window.addEventListener("DOMContentLoaded", () => {
  // Handle and trigger popup window
  document.querySelector(".popup-trigger").addEventListener("click", () => {
    document.querySelector(".popup").classList.add("show");
    setTimeout(() => {
      document.querySelector(".search-input").focus();
    }, 100);
  });

  // Monitor main search box
  const onPopupClose = () => {
    document.querySelector(".popup").classList.remove("show");
  };

  document.querySelector(".popup-btn-close").addEventListener("click", () => {
    onPopupClose();
  });

  window.addEventListener("keyup", event => {
    if (event.key === "Escape") {
      onPopupClose();
    }
  });
});
</script><script src="/js/search/local-search.js" defer></script><div class="popup search-popup"><div class="search-header"><span class="popup-btn-close close-icon hty-icon-button"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-close-line"></use></svg></span></div><div class="search-input-container"><input class="search-input" id="local-search-input" type="text" placeholder="Searching..." value=""><div><img style="margin:0em 0em 0.1em 0em" loading="lazy" src="/images/run.gif" alt="来搜索啊" width="200px" title="wait a moment"></div></div><div id="local-search-result"></div></div><script>const date = new Date();
const today = (date.getMonth() + 1) + "-" + date.getDate()
const mourn_days = ["4-4"]
if (mourn_days.includes(today)) {
  document.documentElement.style.filter = "grayscale(1)";
}</script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"live2d-widget-model-haruto"},"display":{"superSample":2,"width":160,"height":240,"position":"right","hOffset":20,"vOffset":50},"mobile":{"show":false,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.2},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>